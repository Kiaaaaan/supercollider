<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0028ff}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #002bff; min-height: 14.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0028ff; min-height: 14.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Helvetica; min-height: 11.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #e20000}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #007300}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ff0000}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 8.0px Monaco; min-height: 11.0px}
p.p18 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 8.0px Helvetica; min-height: 10.0px}
p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Helvetica; min-height: 11.0px}
p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ff0000; min-height: 12.0px}
p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0030ff}
span.s1 {font: 12.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {color: #00abff}
span.s5 {text-decoration: underline ; color: #00baff}
span.s6 {text-decoration: underline ; color: #0074ff}
span.s7 {text-decoration: underline ; color: #006eff}
span.s8 {text-decoration: underline ; color: #00aaff}
span.s9 {text-decoration: underline ; color: #01a0ff}
span.s10 {text-decoration: underline ; color: #0000ee}
span.s11 {color: #002bff}
span.s12 {text-decoration: underline ; color: #042eee}
span.s13 {color: #0433ff}
span.s14 {text-decoration: underline ; color: #0028ff}
span.s15 {text-decoration: underline ; color: #0433ff}
span.s16 {color: #0019d6}
span.s17 {color: #007300}
span.s18 {color: #0030ff}
span.s19 {color: #0044ff}
span.s20 {color: #002efe}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>PLx, a dynamic scope Pattern suite<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b><span class="s1"><b>dynamic scope Pattern variants<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span></span></b></span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>See also: </b><a href="Event patterns and Functions.html"><span class="s3">Event patterns and Functions</span></a></span><span class="s4">,</span><span class="s2"> <a href="VarGui.html"><span class="s5">VarGui</span></a></span><span class="s4">,</span><span class="s2"> <a href="VarGui shortcut builds.html"><span class="s6">VarGui shortcut builds</span></a>, <a href="Buffer Granulation.html"><span class="s3">Buffer Granulation</span></a></span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4">Environmental variables within functions can act as placeholders for values, but also Patterns itself. So Patterns including functional code (e.g. Pfunc, Plazy, Pcollect) can, thanks to dynamic scoping, turn into different Streams, depending on the environment where streamifying happens (<a href="Event patterns and Functions.html"><span class="s7">Event patterns and Functions</span></a>). This can be used for getting a whole parametrized family of Streams / EventStreamPlayers from a single pattern definition. Other applications are on-the-fly replacements and gui control of parameters of Pbinds / EventStreamPlayers with <a href="VarGui.html"><span class="s5">VarGui</span></a>. Nevertheless constructs with Plazy, Pfunc etc. require some redundant typing which is saved by PLx Patterns (lazy evaluation). They are either plain wrapper classes or include variant implementations for the most common pattern types and deliver a more or less unified way for the described kind of placeholding.</p>
<p class="p4">Unification however can only be approximated as Patterns, even those of one type (e.g. ListPatterns), are defining different behaviour: not all inputs of a source pattern x can be dynamically updated (e.g. the start of a Pseries), not all of them are allowed to be Patterns itself. Implementation and usage may differ a bit from class to class. If there is no PLx implementation of a source Pattern class you can use PL as a general pattern placeholder input, see <a href="PL.html"><span class="s8">PL</span></a> help file for an example.</p>
<p class="p4"><b>NOTE: </b>PLx patterns follow a paradigm of immediate replacement. There are cases though where you might prefer to finish streams or substreams before replacement, especially when syncing comes into play, for these options consider <a href="PLn.html"><span class="s9">PLn</span></a> and the <b>cutItems</b> arg of PLx list patterns.</p>
<p class="p4">A word of caution: feeding a looped process with an invalid input has always the potential to lead to hangs. Main motivation for PLx was a better integration with VarGui, I didn't intend to use on-the-fly replacements in live coding performances. There are no refined proxy features as they e.g. exist in JITLib.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>PLx value and event pattern classes</b></p>
<p class="p6"><br></p>
<p class="p7"><span class="s10"><a href="PL.html">PL</a></span><span class="s11">, <a href="PLn.html"><span class="s12">PLn</span></a></span><span class="s13">, <a href="PLseq.html"><span class="s14">PLseq</span></a></span><span class="s11">, <a href="PLser.html"><span class="s14">PLser</span></a>, <a href="PLrand.html"><span class="s14">PLrand</span></a>, <a href="PLxrand.html"><span class="s15">PLxrand</span></a></span><span class="s13">, <a href="PLwrand.html"><span class="s14">PLwrand</span></a></span><span class="s11">, <a href="PLshuf.html"><span class="s14">PLshuf</span></a>, <a href="PLshufn.html"><span class="s14">PLshufn</span></a>, <a href="PLslide.html"><span class="s15">PLslide</span></a></span><span class="s13">, <a href="PLtuple.html"><span class="s14">PLtuple</span></a></span><span class="s11">, <a href="PLwalk.html"><span class="s14">PLwalk</span></a>, <a href="PLswitch.html"><span class="s14">PLswitch</span></a>, <a href="PLswitch1.html"><span class="s14">PLswitch1</span></a></span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p5"><b>PLx value pattern classes</b></p>
<p class="p6"><br></p>
<p class="p7"><span class="s10"><a href="PLwhite.html">PLwhite</a></span><span class="s11">, <a href="PLlprand.html"><span class="s14">PLlprand</span></a>, <a href="PLhprand.html"><span class="s14">PLhprand</span></a>, <a href="PLmeanrand.html"><span class="s14">PLmeanrand</span></a>, <a href="PLbrown.html"><span class="s14">PLbrown</span></a>, <a href="PLgbrown.html"><span class="s14">PLgbrown</span></a>, <a href="PLseries.html"><span class="s14">PLseries</span></a>, <a href="PLgeom.html"><span class="s14">PLgeom</span></a>, <a href="PLbeta.html"><span class="s14">PLbeta</span></a>, <a href="PLcauchy.html"><span class="s14">PLcauchy</span></a>, <a href="PLgauss.html"><span class="s14">PLgauss</span></a>, <a href="PLpoisson.html"><span class="s14">PLpoisson</span></a>, <a href="PLexprand.html"><span class="s14">PLexprand</span></a></span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p5"><b>PLx filter pattern classes</b></p>
<p class="p2"><br></p>
<p class="p7"><span class="s10"><a href="PLnaryop.html">PLnaryop</a></span><span class="s11">, <a href="PLnaryFunc.html"><span class="s14">PLnaryFunc</span></a></span></p>
<p class="p9"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>Example 1a:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ListPatterns placeholder constructs with Plazy</b></p>
<p class="p10"><br></p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">s = <span class="s16">Server</span>.local;</p>
<p class="p12"><span class="s16">Server</span>.default = s;</p>
<p class="p12">s.boot;</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p13">// This is how dynamic scope placeholding of a ListPattern<span class="Apple-converted-space"> </span></p>
<p class="p13">// could be done with Plazy,</p>
<p class="p13">// Pn defaults to repeats = inf.</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s16">Pn</span>(<span class="s16">Plazy</span> { <span class="s16">Pseq</span>(~a, 1) });<span class="Apple-converted-space"> </span></p>
<p class="p11"><br></p>
<p class="p12">~a = (60..70);</p>
<p class="p11"><br></p>
<p class="p12">x = <span class="s16">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, p,</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.2</p>
<p class="p12">).play;</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// First drawback: replacing of a new list doesn't have an immediate effect</p>
<p class="p15">// as the old list is looped through before.</p>
<p class="p11"><br></p>
<p class="p15">// Try evaluating this before the end of the original loop.</p>
<p class="p11"><br></p>
<p class="p12">~a = (75..84) ++ <span class="s18">Pseq</span>([85,86], 10);</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// Second drawback: replacing of a single pattern element,<span class="Apple-converted-space"> </span></p>
<p class="p15">// which corresponds to a stream just being embedded,</p>
<p class="p15">// doesn't have an immediate effect</p>
<p class="p15">// as this embedding is finished before.</p>
<p class="p11"><br></p>
<p class="p15">// Try evaluating this during the trill, it doesn't have an<span class="Apple-converted-space"> </span></p>
<p class="p15">// effect before the next loop.</p>
<p class="p11"><br></p>
<p class="p12">~a[10] = 91;</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p4">Similar placeholder constructs with Pcollect and Pfunc have similar drawbacks concerning replacement. However, this type of "delayed replacement" might be wanted in some cases and is also possible with PLx patterns, see <a href="PLn.html"><span class="s9">PLn</span></a> and the <b>cutItems</b> arg of PLx list patterns.</p>
<p class="p16"><br></p>
<p class="p17"><br></p>
<p class="p17"><br></p>
<p class="p5"><b>Example 1b:<span class="Apple-tab-span">	</span>PLx implementation of ListPatterns</b></p>
<p class="p17"><br></p>
<p class="p17"><br></p>
<p class="p4">PLx Patterns take symbols as input. Derived Streams get the values of the Environment of streamification.</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PLseq</span><span class="s2">(</span>\a<span class="s2">),</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.2</p>
<p class="p12">);</p>
<p class="p11"><br></p>
<p class="p12">~a = (60..70);</p>
<p class="p11"><br></p>
<p class="p12">y = p.play;</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replacement of the whole list has an immediate effect now,</p>
<p class="p15">// with Pseq the loop starts with the new list</p>
<p class="p11"><br></p>
<p class="p12">~a = (75..84) ++ <span class="s18">Pseq</span>([85,86], 10);</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replacing a single element also has an immediate effect<span class="Apple-converted-space"> </span></p>
<p class="p15">// (as PLseq's cutItems arg defaults to true),</p>
<p class="p15">// try evaluating during the trill</p>
<p class="p11"><br></p>
<p class="p12">~a[10] = 91;</p>
<p class="p11"><br></p>
<p class="p12">y.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// PLx ListPattern implementations can also act as<span class="Apple-converted-space"> </span></p>
<p class="p15">// ordinary ListPatterns if args are not Symbols.<span class="Apple-converted-space"> </span></p>
<p class="p15">// Difference: repeats arg defaults to inf,<span class="Apple-converted-space"> </span></p>
<p class="p15">// so you save typing in this case,</p>
<p class="p15">// but don't apply .all to Streams derived from such Patterns !</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">x = <span class="s18">Pbind</span>(</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\midinote</span>, <span class="s18">PLseq</span>((60..70)),</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.2</p>
<p class="p12">).play;</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>Example 1c:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>PLx implementation of Non-ListPatterns<span class="Apple-converted-space"> </span></b></p>
<p class="p18"><br></p>
<p class="p18"><br></p>
<p class="p15">// an explicit definition with Plazy</p>
<p class="p11"><br></p>
<p class="p12">p = <span class="s18">Pwhite</span>(<span class="s18">Pn</span>(<span class="s18">Plazy</span> { ~lo }), <span class="s18">Pn</span>(<span class="s18">Plazy</span> { ~hi }), { ~r });</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// similarily done implicitely by PLwhite</p>
<p class="p11"><br></p>
<p class="p12">q = <span class="s18">PLwhite</span>(<span class="s17">\lo</span>, <span class="s17">\hi</span>, <span class="s17">\r</span>);<span class="Apple-converted-space"> </span></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// streamify in envir</p>
<p class="p11"><br></p>
<p class="p12">e = (lo: 60, hi: 90, r: 30);</p>
<p class="p11"><br></p>
<p class="p12">e.use { q.asStream.all };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// reset repeats to inf and streamify again</p>
<p class="p11"><br></p>
<p class="p12">e.use { ~r = <span class="s18">inf</span>; x = <span class="s18">Pbind</span>(<span class="s17">\midinote</span>, q, <span class="s17">\dur</span>, 0.2).play };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replace lower bound by pattern</p>
<p class="p11"><br></p>
<p class="p12">e.lo = <span class="s18">PLseq</span>([60, 90]);</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p5"><b>Example 1d:<span class="Apple-tab-span">	</span>Plain PL</b></p>
<p class="p2"><br></p>
<p class="p4">A general placeholder that can be updated after instantiation.</p>
<p class="p4">Its repeats arg defaults to inf.</p>
<p class="p2"><br></p>
<p class="p19"><br></p>
<p class="p12"><span class="s18">PL</span>(<span class="s17">\a</span>, <span class="s17">\r</span>);</p>
<p class="p11"><br></p>
<p class="p15">// roughly equivalent to</p>
<p class="p19"><br></p>
<p class="p12"><span class="s18">Pn</span>(<span class="s18">Plazy</span> { ~a }, { ~r });</p>
<p class="p19"><br></p>
<p class="p11"><br></p>
<p class="p12">e = (a: <span class="s18">Pseq</span>((60, 62.5..80)));</p>
<p class="p11"><br></p>
<p class="p12">e.use { x = <span class="s18">Pbind</span>(<span class="s17">\midinote</span>, <span class="s18">PL</span>(<span class="s17">\a</span>), <span class="s17">\dur</span>, 0.1).play }</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// note that with this replacement new scrambles are chosen<span class="Apple-converted-space"> </span></p>
<p class="p15">// repeatedly because Pshuf's repeats arg defaults to 1.</p>
<p class="p11"><br></p>
<p class="p12">e.a = <span class="s18">Pshuf</span>((80, 78.5..65));</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// fixed reordering</p>
<p class="p11"><br></p>
<p class="p12">e.a = <span class="s18">Pshuf</span>((80, 78.5..65), <span class="s18">inf</span>);</p>
<p class="p11"><br></p>
<p class="p12">e.a = <span class="s18">PLshuf</span>((80, 78.5..65));</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p4">PL can also be used with Patterns which don't have a PLx implementation.</p>
<p class="p4">See <a href="PL.html"><span class="s8">PL</span></a> for an example.</p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p5"><b>Example 2:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Playing in different Environments<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span></span></b></p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p15">// Pbind to be streamified differently in different environments</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PLseq</span><span class="s2">(</span>\a<span class="s2">),</span></p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\dur<span class="s2">, </span><span class="s18">PL</span><span class="s2">(</span>\d<span class="s2">)</span></p>
<p class="p12">);</p>
<p class="p11"><br></p>
<p class="p12">e = (a: (67..72), d: 0.1);</p>
<p class="p12">f = (a: (85..90), d: 0.2);</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// start in sync or individually</p>
<p class="p11"><br></p>
<p class="p12">x = e.use { p.play(quant: 0.2) };</p>
<p class="p12">y = f.use { p.play(quant: 0.2) };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replacement of array elements ...</p>
<p class="p11"><br></p>
<p class="p12">e.a[0] = 95;</p>
<p class="p12">f.a[0] = [75, 79];</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// ... which may also be Patterns</p>
<p class="p11"><br></p>
<p class="p12">f.a[0] = <span class="s18">Pseq</span>([75, 79], 3);</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replacing the whole array</p>
<p class="p11"><br></p>
<p class="p12">f.a = (83..80);</p>
<p class="p11"><br></p>
<p class="p12">f.a = (79..75) +.t [0, 3.5];</p>
<p class="p11"><br></p>
<p class="p12">e.a = [<span class="s18">Pseq</span>([63, 65.5], 4), 85, 87];</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p12">y.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p5"><b>Example 3:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Use with VarGui<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span></span></b></p>
<p class="p19"><br></p>
<p class="p15">// basic form of a step sequencer (amp defaults to 0 in associated global ControlSpec)</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12"><span class="s17">\default</span>.pVarGui(</p>
<p class="p12"><span class="Apple-tab-span">	</span>ctrBefore: [<span class="s17">\a</span>, [0, 6, <span class="s17">\lin</span>, 1, 3] ! 8],</p>
<p class="p12"><span class="Apple-tab-span">	</span>pBefore: [<span class="s17">\degree</span>, <span class="s19">PLseq</span>(<span class="s17">\a</span>) ]</p>
<p class="p12">).gui;</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p4">See <a href="VarGui.html"><span class="s5">VarGui</span></a><span class="s5"> </span>and <a href="VarGui shortcut builds.html"><span class="s6">VarGui shortcut builds</span></a> for further examples.</p>
<p class="p16"><br></p>
<p class="p16"><br></p>
<p class="p16"><br></p>
<p class="p5"><b>Example 4:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The repeats arg<span class="Apple-tab-span">	</span></b></p>
<p class="p19"><br></p>
<p class="p20"><br></p>
<p class="p4">PLx Patterns' repeats arg defaults to inf. This makes sense in situations where you want to go on replacing items on the fly. If a PLx Patterns is itself enclosed you may want to set it to a different value. Anyway the resulting number of repeats is the product of outer and inner repeats.</p>
<p class="p20"><br></p>
<p class="p20"><br></p>
<p class="p11"><br></p>
<p class="p15">// PL(\a) defaults to repeats = inf</p>
<p class="p15">// Pshuf defaults to repeats = 1, is embedded repeatedly and<span class="Apple-converted-space"> </span></p>
<p class="p15">// so it continues producing new permutations (like Pshufn)</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PL</span><span class="s2">(</span>\a<span class="s2">),</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.15</p>
<p class="p12">);</p>
<p class="p11"><br></p>
<p class="p12">~a = <span class="s18">Pshuf</span>((60..63));</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12">x = p.play;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// same effect, but this is normal Pshufn behaviour</p>
<p class="p11"><br></p>
<p class="p12">~a = <span class="s18">Pshufn</span>((60..63));</p>
<p class="p12">~a = <span class="s18">Pshufn</span>((60..63), <span class="s18">inf</span>);</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// PL(\a, 2) demands inner repeats = inf for endless running</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PL</span><span class="s2">(</span>\a<span class="s2">, 2),</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.15</p>
<p class="p12">);</p>
<p class="p11"><br></p>
<p class="p12">~a = <span class="s18">Pshuf</span>((60..63), <span class="s18">inf</span>); <span class="Apple-converted-space"> </span></p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p15">// now normal Pshuf behaviour</p>
<p class="p11"><br></p>
<p class="p12">x = p.play;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// same achieved with PLshuf((60..63)) as it defaults to repeats = inf</p>
<p class="p11"><br></p>
<p class="p12">~a = <span class="s20">PLshuf</span>((60..63));</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// stop with a Pseq which defaults to repeats = 1, played twice because of PL(\a, 2)</p>
<p class="p11"><br></p>
<p class="p12">~a = <span class="s20">Pseq</span>((70..65));</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p5"><b>Example 5a:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Updating input of N-ary operators<span class="Apple-tab-span">	</span></b></p>
<p class="p6"><br></p>
<p class="p4">One may want to have the choice to update inputs of N-ary operators applied to Patterns too. A common case is clipping. Say you have a Pcauchy pattern (distribution with a relatively high number of outliers) and want to dynamically change its mean value and clip bounds.</p>
<p class="p19"><br></p>
<p class="p11"><br></p>
<p class="p15">// PLcauchy allows updating mean and spread arg (also with patterns)</p>
<p class="p15">// the collect function will read from envir variables with every new event</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\midinote</span>, <span class="s18">PLcauchy</span>(<span class="s17">\m</span>, <span class="s17">\s</span>).collect(<span class="s18">_</span>.clip(~lo, ~hi)),</p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.1</p>
<p class="p12">);</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p15">// define the environment</p>
<p class="p11"><br></p>
<p class="p12">e = (m: 75, s: 1, lo: 60, hi: 90);</p>
<p class="p11"><br></p>
<p class="p12">e.use { x = p.play };</p>
<p class="p11"><br></p>
<p class="p15">// update upper bound to mean value</p>
<p class="p11"><br></p>
<p class="p12">e.hi = 75;</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// above pitch pattern could be written explicitely too with Pnaryop<span class="Apple-converted-space"> </span></p>
<p class="p11"><br></p>
<p class="p12"><span class="s18">Pnaryop</span>(<span class="s17">\clip</span>, <span class="s18">PLcauchy</span>(<span class="s17">\m</span>, <span class="s17">\s</span>), [<span class="s18">Pfunc</span> { ~lo }, <span class="s18">Pfunc</span> { ~hi }])</p>
<p class="p11"><br></p>
<p class="p15">// more powerful: PL allows updating with patterns</p>
<p class="p11"><br></p>
<p class="p21">Pnaryop<span class="s2">(</span><span class="s17">\clip</span><span class="s2">, </span>PLcauchy<span class="s2">(</span><span class="s17">\m</span><span class="s2">, </span><span class="s17">\s</span><span class="s2">), [</span>PL<span class="s2">(</span><span class="s17">\lo</span><span class="s2">), </span>PL<span class="s2">(</span><span class="s17">\hi</span><span class="s2">)])</span></p>
<p class="p11"><br></p>
<p class="p15">// even shorter: the PLnaryop class expands to the above</p>
<p class="p11"><br></p>
<p class="p21">PLnaryop<span class="s2">(</span><span class="s17">\clip</span><span class="s2">, </span>PLcauchy<span class="s2">(</span><span class="s17">\m</span><span class="s2">, </span><span class="s17">\s</span><span class="s2">), [</span><span class="s17">\lo</span><span class="s2">, </span><span class="s17">\hi]</span><span class="s2">)</span></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// In the simple case of updating clip bounds with values<span class="Apple-converted-space"> </span></p>
<p class="p15">// maybe one would rather use the version with collect.</p>
<p class="p11"><br></p>
<p class="p15">// But with Pnaryop you can pass a list of arbitrary patterns as arglist</p>
<p class="p15">// and with PLnaryop you can dynamically update with arbitrary patterns -</p>
<p class="p15">// both can be used for more differentiated control of clip bounds</p>
<p class="p15">// (or args of any other N-ary operator or Function).</p>
<p class="p15">// Also the source pattern can be replaced.</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PLnaryop</span><span class="s2">(</span>\clip<span class="s2">, </span>\pat<span class="s2">, [</span>\lo<span class="s2">, </span>\hi]<span class="s2">),</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.1</p>
<p class="p12">);</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p15">// define the environment and play</p>
<p class="p11"><br></p>
<p class="p12">e = (pat: <span class="s18">PLcauchy</span>(<span class="s17">\m</span>, <span class="s17">\s</span>), m: 75, s: 1, lo: 60, hi: 90);</p>
<p class="p11"><br></p>
<p class="p12">e.use { x = p.play };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// compare distributions</p>
<p class="p11"><br></p>
<p class="p12">e.pat = <span class="s18">PLgauss</span>(<span class="s17">\m</span>, <span class="s17">\s</span>);</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// switch back to Cauchy with more outliers</p>
<p class="p11"><br></p>
<p class="p12">e.pat = <span class="s18">PLcauchy</span>(<span class="s17">\m</span>, <span class="s17">\s</span>);</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// update bounds, lo bound 85 is mostly gone below,<span class="Apple-converted-space"> </span></p>
<p class="p15">// so nearly every second event has this midinote</p>
<p class="p15">// vice versa with hi bound 65</p>
<p class="p11"><br></p>
<p class="p12">e.lo = <span class="s18">PLseq</span>([60, 85]);</p>
<p class="p11"><br></p>
<p class="p12">e.use { ~lo = 60; ~hi = <span class="s18">PLseq</span>([65, 90]) };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// clipping to a window that loops through the distribution:</p>
<p class="p15">// values are taking more or less the wandering clip bounds if lo or hi,<span class="Apple-converted-space"> </span></p>
<p class="p15">// but are rather randomly distributed between clip bounds around the mean value</p>
<p class="p11"><br></p>
<p class="p12">e.use { ~lo = <span class="s18">PLseq</span>((50..95)); ~hi = ~lo + 10 };</p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p4">For replacing operators dynamically take PLnaryFunc with the operator wrapped into a Function.</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p5"><b>Example 5b:<span class="Apple-tab-span">	</span>Updating input of N-ary Functions<span class="Apple-tab-span">	</span></b></p>
<p class="p6"><br></p>
<p class="p4">Self-defined functions can be used as with PLnaryop.</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">p = <span class="s18">Pbind</span>(</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>\midinote<span class="s2">, </span><span class="s18">PLnaryFunc</span><span class="s2">(</span>\f<span class="s2">, </span>\src<span class="s2">, [</span>\b<span class="s2">, </span>\c]<span class="s2">),</span></p>
<p class="p12"><span class="Apple-tab-span">	</span><span class="s17">\dur</span>, 0.1</p>
<p class="p12">);</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p15">// define Environment</p>
<p class="p11"><br></p>
<p class="p12">(</p>
<p class="p12">e = ();</p>
<p class="p11"><br></p>
<p class="p12">e.src = <span class="s18">Pstutter</span>(3, <span class="s18">PLseq</span>((60, 70..90)));</p>
<p class="p12">e.b = <span class="s18">PLseq</span>((0..2));</p>
<p class="p12">e.c = 0;</p>
<p class="p11"><br></p>
<p class="p12">e.f = { <span class="s18">|x,y,z|</span> x + y + z };</p>
<p class="p12">)</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// run</p>
<p class="p11"><br></p>
<p class="p12">e.use { x = p.play };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replace function input</p>
<p class="p11"><br></p>
<p class="p12">e.b = <span class="s18">PLseq</span>((0..1));</p>
<p class="p11"><br></p>
<p class="p12">e.c = [-5, 0];</p>
<p class="p11"><br></p>
<p class="p12">e.c = <span class="s18">PLseq</span>([[-5, 0], [0, 3]]);</p>
<p class="p11"><br></p>
<p class="p12">e.b = <span class="s18">PLshuf</span>((0..3));</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p15">// replace function</p>
<p class="p11"><br></p>
<p class="p12">e.f = { <span class="s18">|x,y,z|</span> x + (y * 1.2) + z };</p>
<p class="p11"><br></p>
<p class="p12">e.f = { <span class="s18">|x,y,z|</span> x + y + (z * 1.7) };</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p12">x.stop;</p>
<p class="p11"><br></p>
<p class="p6"><br></p>
<p class="p11"><br></p>
</body>
</html>
